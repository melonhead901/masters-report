\documentclass{article}

\usepackage{caption}
\usepackage{code}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{multirow}
\usepackage{url}
\usepackage{verbatim}
\usepackage{fancyvrb}
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{color}
\usepackage{colortbl}

\definecolor{Gray}{gray}{0.9}
\newcommand\ch[1]{\textcolor[rgb]{0,0,1}{\textbf{#1}}}
\newcommand\clh[1]{\textcolor[rgb]{0,.5,1}{\textbf{#1}}}
\newcommand\coh[1]{\textcolor[rgb]{0,.6,0}{\textbf{#1}}}

\newtheorem{research-question}{Research Question}[section]

\newcommand{\todo}[1]{{\color{red}\bfseries [[#1]]}}

\title{Celeriac: A Daikon .NET Front End}
\author{Kellen Donohue\\ \\
University of Washington, Computer Science \& Engineering\\ \\}
\begin{document}
\maketitle

\section{Introduction}
\subsection{Contracts}
Contracts provide an agreement between a method implementer and caller, and also describe well-formed object. The following code snippet shows how a typical bank account withdraw method may be annotated with contracts.
\begin{center}
\begin{Verbatim}[commandchars=\\\{\}]

\ch{class} BankAccount \{
  \ch{bool} Withdraw(\clh{Account} acct, \ch{decimal} amt) \{
      \coh{// Don't withdraw a negative amount.}
      \clh{Contract}.Requires(amt >= 0);
      \coh{// Return whether withdraw succeeded.}
      \clh{Contract}.Ensures(
        \clh{Contract}.Result<\ch{bool}>() == acct.bal >= amt);
      \coh{// Update the account properly.}
      \clh{Contract}.Ensures(acct.bal ==
        \clh{Contract}.OldValue(acct.bal) - \clh{Contract}.Result<\ch{bool}>()
        ? amt : 0);
      ...
  \}
\}
\end{Verbatim}
\end{center} \captionof{figure}{Bank Account With Contracts}
\  \\
Contracts are useful for ensuring the correct behavior of programs. Additionally, the .NET framework has many tools that are enhanced by the use of contracts, in a framework called CodeContracts. The Pex white-box test generation tool \cite{pex} won't generate tests that violate specified contracts, which is important for ensuring that generated tests satisfy a specification. Developers can use contracts to statically verify program properties \cite{static} and automatically generate API documentation \cite{contracts}.

\subsection{Daikon}
To help developers insert appropriate contracts the Daikon tool \cite{daikon} dynamically detects likely program invariants. It takes as input a program trace, and outputs a list of possible invariants based on that trace.  The following figure demonstrates a code snippet and the possible invariants that Daikon may infer on the snippet.

\begin{center}
\begin{Verbatim}[commandchars=\\\{\}]
\ch{public void} makeEmpty() \{
    \clh{Arrays}.fill(theArray, 0, topOfStack + 1, \ch{null});
    topOfStack = -1;
\}

-----------------------------------------------------

Daikon Invariants:
DataStructures.StackAr.makeEmpty():::EXIT
size(this.theArray[]) == orig(size(this.theArray[]))
this.theArray[] elements == null
this.topOfStack == -1
this.theArray[0..this.topOfStack] == []
this.topOfStack <= orig(this.topOfStack)

\end{Verbatim}
\end{center} \captionof{figure}{Daikon Example}
\  \\
In this example all the Daikon inferred invariants are true of the source code, however that is not always the case. Since Daikon can only output invariants based on input traces it may output invariants that are too weak (since it is limited by the type of invariants that may occur) or too strong (since it may over-generalize if given a trace that doesn't well demonstrate the program).
\\ \\
Daikon works as follows, and as described in the figure below. First, front-end modifies a program to add instrumentation calls which output a data trace during execution. During this process a declaration file, or description of the program schema in terms of methods and variables is output. The datatrace created during execution along with the declaration file are then run through Daikon, which outputs a list of possible program invariants. These invariants can be inserted as contracts, assertions, or documentation in the source program, among a variety of other possible uses.

\begin{center}
\includegraphics[scale=.5]{daikon}
\end{center} \captionof{figure}{Operation of Daikon}

\subsection{Contributions}
The contribution of this work is as follows. The technical contribution is Celeriac, a Daikon front end for the .NET programming languages C\#, F\#, and VB.NET. The research contribution is an investigation of which types of contracts developers choose to include in their programs, and why. Section 2 described how Celeriac relates to other Daikon front ends, and other .NET profiler tools. Section 3 describes the use of Celeriac. Section 4 describes the implementation of Celeriac, including important design contributions. Section 5 describes the application of Celeriac to answer software engineering questions. Finally, Section 6 concludes with a summary of the contributions and future work.

\section{Related Work}
Daikon .NET front ends exist for some other languages. The Chicory front end, for Java, is very popular, and Celeriac was modeled after the external behavior or Chicory in many cases. The Kvasir front end, for C++, was a model for the testing suite as well.
\\ \\
Celeriac is unique among Daikon front ends in that no other front end has been written for a functional language, such as F\#. Also, no other front ends have explicitly targeted a multi-language platform, such as .NET.

\section{User Documentation}

\section{Developer Documentation}

\section{Research Experiments}
The primary research question Celeriac answers is what kinds of contracts are inferred from real programs and libraries. Important related research questions are, which of these inferred contracts do developers choose to include in their subject. To answer these questions a study was done on programs C\# open source programs that contained Code Contracts.

\input{subject-programs}
\input{paper-celeriac}

\section{Conclusion}

\newpage
\bibliographystyle{plain}
\bibliography{thesis}

\end{document} 